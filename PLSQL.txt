				PL/ SQL:::
				------------

1. Pl/SQL stands for "Procedural Language extension of SQL" that is used in Oracle.
2. The programs of PL/SQL are logical blocks that can contain any number of nested sub-blocks.
3. Although PL/SQL is closely integrated with SQL language, yet it adds some programming constraints that are not available in SQL.
4. PL/SQL is not case sensitive.


	1. PROCEDURE
	2. FUNCTIONS
	3. CUSROR
	4.TRIGGER

	

	1. PROCEDURE:::
	______________________

The PL/SQL stored procedure or simply a procedure is a PL/SQL block which performs one or more specific tasks. It is just like procedures in other programming languages.

The procedure contains a header and a body.

~~Header: The header contains the name of the procedure and the parameters or variables passed to the procedure.
~~Body: The body contains a declaration section, execution section and exception section similar to a general PL/SQL block.

***NOTE::first of all you have to create one table.

SYNTAX::
------------

CREATE [OR REPLACE] PROCEDURE procedure_name  
    [ (parameter [,parameter]) ]  
IS  
    [declaration_section]  
BEGIN  
    executable_section  
[EXCEPTION  
    exception_section]  
END [procedure_name];  
/


Syntax for drop procedure::

DROP PROCEDURE procedure_name;



		2. FUNCTION::
		________________

1.The PL/SQL Function is very similar to PL/SQL Procedure.
2.The main difference between procedure and a function is, a function must always return a value, and on the other hand a procedure may or may not return a value.

SYNTAX:::
____________

CREATE [OR REPLACE] FUNCTION function_name [parameters]  
RETURN return_datatype  
{IS | AS}  
BEGIN  
   < function_body >  
END [function_name];  


>>EXAMPLE::

create [or replace] function adder(n1 in number, n2 in number)    
return number    
is     
n3 number(8);    
begin    
n3 :=n1+n2;    
return n3;    
end;    
/    

Now write another program to CALL THE FUNCTION.   

DECLARE    
   n3 number(2);    
BEGIN    
   n3 := adder(11,22);    
   dbms_output.put_line('Addition is: ' || n3);    
END;    
/    

Output:

Addition is: 33
Statement processed.
0.05 seconds

SYNTAX FOR DROP::

DROP FUNCTION function_name; 




		3. CURSOR::
		________________

1.When an SQL statement is processed, Oracle creates a memory area known as context area.
2.A cursor is a pointer to this context area.
3.In PL/SQL, the context area is controlled by Cursor.

There are two types of cursors:

Implicit Cursors
Explicit Cursors

>>IMPLICIT CURSOR::

1.The implicit cursors are automatically generated by Oracle while an SQL statement is executed.
 2.user cannot control the behavior of those  cursor
3.Oracle server creates an implicit cursor for any PL/SQL block which executes an SQL statements.

>>EXPLICIT CURSOR::

They are user-defined
User has full control

Steps:
You must follow these steps while working with an explicit cursor.

>Declare the cursor to initialize in the memory.
>Open the cursor to allocate memory.
>Fetch the cursor to retrieve data.
>Close the cursor to release allocated memory.

1) Declare the cursor:
It defines the cursor with a name and the associated SELECT statement.

Syntax for explicit cursor decleration

CURSOR name IS  
 SELECT statement;   

2) Open the cursor:
It is used to allocate memory for the cursor and make it easy to fetch the rows returned by the SQL statements into it.

Syntax for cursor open:

OPEN cursor_name;  

3) Fetch the cursor:
It is used to access one row at a time. You can fetch rows from the above-opened cursor as follows:

Syntax for cursor fetch:

FETCH cursor_name INTO variable_list;  

4) Close the cursor:
It is used to release the allocated memory. The following syntax is used to close the above-opened cursors.

Syntax for cursor close:

Close cursor_name;  



			4. TRIGGER::
			____________

1.Trigger is invoked by Oracle engine automatically whenever a specified event occurs.
2.Triggers are stored programs, which are automatically executed or fired when some event occurs.

Advantages of Triggers::
----------------------------

~Trigger generates some derived column values automatically
~Enforces referential integrity
~Event logging and storing information on table access Auditing
~Synchronous replication of tables
~Imposing security authorizations
~Preventing invalid transactions